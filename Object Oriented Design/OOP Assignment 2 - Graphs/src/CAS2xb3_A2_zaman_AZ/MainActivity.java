/** @file MainActivity.java
@author Anando Zaman
@brief Essentially like a Controller class
@date March 25,2020
@details Executes DFS, BFS along with Dijkstras_shortpaths for optimal paths and outputs to data/a2.out.txt
*/

/* Student Information
* -------------------
* Student Name: Zaman, Anando
* Course Code: CS/SE 2XB3
* Lab Section: 02
*
* I attest that the following code being submitted is my own individual
work.
*/

package CAS2xb3_A2_zaman_AZ;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Stack;
import java.util.Vector;

import CAS2xb3_A2_zaman_AZ.GraphCreation.*;
import CAS2xb3_A2_zaman_AZ.GraphTraversal.*;
import CAS2xb3_A2_zaman_AZ.Restaurants.LowestMealCost;
import CAS2xb3_A2_zaman_AZ.ShortestPathAlgos.Dijkstras_shortpaths;


/** Essentially the Controller class to compute DFS,BFS along with Dikstras algorithm for cheapest meals path
 * INPUT DATA LOCATION: /data/input.txt
 * OUTPUT DATA: data/a2.out.txt
 * **/
public class MainActivity {
	
	/** Static method that writes a given string to a file **/
    public static void Write_to_file(String str) 
	{ 
		try { 
			BufferedWriter output = new BufferedWriter(new FileWriter("data/a2_out.txt", true)); //append mode set to true
			output.write(str); 
			output.close(); 
		} 
		catch (IOException e) { 
			System.out.println("ERROR, could not write to file"); 
		} 
	} 
	
	
	public static void main(String[] args) throws FileNotFoundException {		
		/**LOAD INPUT START/END DATA**/
		/**INPUT DATA LOCATION: /data/input.txt**/
		Scanner input = new Scanner(new File("data/input.txt"));
		String[] start_end = new String[2]; //array that contains [start_city, end_city]
		int i = 0;
		while (i<2){
			start_end[i] = input.nextLine().trim().toUpperCase();
			i++;	
		}
		input.close();
		
		
		/**CREATE UNDIRECTED GRAPH**/
		ArrayList<ArrayList<Object>> initial_cities_list = graph_create.initial_cities_list(); //Extracts the available cities from USCITIES Dataset
		graph_create city_graph = new graph_create(initial_cities_list); //initialize empty graph with these cities that have null adjacency lists
		city_graph.create_edges(); //create the edges. Essentially, creates adjacency lists for each city
		
		
		/**RUN BFS FOR PATH FROM START TO END. start_end[0] represents start, start_end[1] represents end**/
		/** PATH STORED IN REVERSE_ORDER IN STACK. POPS FROM STACK TO GET FORWARDS ORDER**/
		ArrayList<String> BFS_path = new ArrayList<String>(); //Used to contain Forwards order path
		if (BFS.validStart(start_end[0], city_graph) && BFS.validEnd(start_end[1], city_graph)) {
			
			//Execute BFS
			BFS.bfs(start_end[0], start_end[1], city_graph);
			Stack<String> path = BFS.pathTo(start_end[0], start_end[1]);
			Write_to_file("BFS: ");
			System.out.print("BFS: ");
			String BFS_pop;
			
			//Print Path generated by BFS from start to end
			while(!path.isEmpty()) {
				BFS_pop = path.pop();//save top element
				BFS_path.add(BFS_pop);//add top element to forwards order list
				
				if(path.size()>0) {
					Write_to_file(BFS_pop + ", "); 
					System.out.print(BFS_pop + ", ");
				}
				
				else {
					Write_to_file(BFS_pop + " "); 
					System.out.print(BFS_pop + " ");
				}
				
			}
			Write_to_file("\n");
			System.out.println();
			
		} else {
			System.out.println("Invalid Start or End Point");
		}
		
		
		
		/**RUN DFS FOR PATH FROM START TO END**/
		/** PATH STORED IN REVERSE IN STACK. POP FROM STACK TO GET FORWARDS ORDER**/
		ArrayList<String> DFS_path = new ArrayList<String>(); //Used to contain Forwards order path
		if (DFS.validStart(start_end[0], city_graph) && DFS.validEnd(start_end[1], city_graph)) {
			
			//Execute DFS
			DFS.dfs(start_end[0], start_end[1], city_graph);
			Stack<String> path = DFS.pathTo(start_end[0],start_end[1]);
			Write_to_file("DFS: ");
			System.out.print("DFS: ");
			String DFS_pop;
			
			//Print path generated by DFS for start-end coordinates
			while(!path.isEmpty()) {
				DFS_pop = path.pop();
				DFS_path.add(DFS_pop);
				if(path.size()>0) {
					Write_to_file(DFS_pop + ", "); 
					System.out.print(DFS_pop + ", ");
				}
				else {
					Write_to_file(DFS_pop + " "); 
					System.out.print(DFS_pop + " ");
				}
			}
			System.out.println("\n");
			
		} else {
			System.out.println("Invalid Start or End Point");
		}
		
		
		/**SHORTEST PATHS FINDER
		 * OUTPUT AS TABLE
		 * **/
		Write_to_file("\n");
		Write_to_file("\n");
		String total_cost = null;
		
		if (city_graph.containsKey(start_end[0]) && city_graph.containsKey(start_end[1])) {
			
			//Dijkstras shortest path object setup
			Dijkstras_shortpaths undirectedSP = new Dijkstras_shortpaths(start_end[0],city_graph);
			ArrayList<String> path = undirectedSP.pathTo(start_end[0],start_end[1]); //computes shortest path
			Vector<Object> meals = LowestMealCost.paths_price_sorted(path,city_graph); //arraylist with cheapest meals for each city on path
			
			String meal_choice;
			String meal_price;
			Write_to_file(String.format("%-22s%-40s%-22s\n","CITY", "MEAL CHOICE", "MEAL COST")); 
			Write_to_file(String.format("%-22s%-40s%-22s\n","-----------", "-----------", "-----------")); 
			System.out.printf("%-22s%-40s%-22s\n","CITY", "MEAL CHOICE", "MEAL COST");
			
			//Output meal and city information to the a2_out.txt output file
			for(int index = 0; index < path.size(); index++) {
				meal_choice = (String) ((Vector<Object>)meals.get(index)).get(1);
				meal_price = (String) ((Vector<Object>)meals.get(index)).get(2);
				
				Write_to_file(String.format("%-22s%-40s%-22s\n",path.get(index), meal_choice, meal_price)); 
				System.out.printf("%-22s%-40s%-22s\n",BFS_path.get(index), meal_choice, meal_price);
			}
			total_cost = (String) meals.get(path.size());
		}
		else {
			System.out.println("Invalid Start or End Point");
		}
		
		Write_to_file(String.format("%-22s%-40s%-22s\n","", "", "-------"));
		Write_to_file(String.format("%-22s%-40s%-22s\n","", "", String.valueOf(total_cost)));
		System.out.printf("%-22s%-40s%-22s\n","", "", "-------");
		System.out.printf("%-22s%-40s%-22s\n","", "", String.valueOf(total_cost));
		
	}
}
